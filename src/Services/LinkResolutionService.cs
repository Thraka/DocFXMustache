using System;
using System.Collections.Generic;
using System.IO;
using DocFXMustache.Models;

namespace DocFXMustache.Services;

/// <summary>
/// Service for resolving UIDs to file paths and calculating relative paths between files.
/// Used in both Pass 1 (recording) and Pass 2 (resolution).
/// </summary>
public class LinkResolutionService
{
    private readonly Dictionary<string, OutputFileInfo> _uidToOutputInfo = new();
    private readonly Dictionary<string, string> _externalReferences = new();
    
    #region Pass 1: Recording Generated Files
    
    /// <summary>
    /// Records a generated file for a UID (Pass 1).
    /// </summary>
    /// <param name="uid">The UID of the documented item</param>
    /// <param name="filePath">The full path to the generated file</param>
    /// <param name="anchor">Optional anchor for member links</param>
    public void RecordGeneratedFile(string uid, string filePath, string? anchor = null)
    {
        _uidToOutputInfo[uid] = new OutputFileInfo
        {
            FilePath = filePath,
            Anchor = anchor
        };
    }
    
    /// <summary>
    /// Records an external reference from YAML metadata (Pass 1).
    /// Stores all hrefs from the references section for use as fallback when resolving links.
    /// Generated files (recorded via RecordGeneratedFile) take precedence over these references.
    /// </summary>
    /// <param name="uid">The UID of the referenced item</param>
    /// <param name="href">The href from YAML (can be relative path or absolute URL)</param>
    public void RecordExternalReference(string uid, string href)
    {
        _externalReferences[uid] = href;
    }
    
    /// <summary>
    /// Gets the output file information for a UID.
    /// </summary>
    /// <param name="uid">The UID to look up</param>
    /// <returns>The output file information</returns>
    /// <exception cref="KeyNotFoundException">Thrown when UID is not found</exception>
    public OutputFileInfo GetOutputInfo(string uid)
    {
        if (!_uidToOutputInfo.TryGetValue(uid, out var info))
        {
            throw new KeyNotFoundException($"UID not found in mappings: {uid}");
        }
        return info;
    }
    
    #endregion
    
    #region Pass 2: Link Resolution
    
    /// <summary>
    /// Resolves an internal link from current file to target UID (Pass 2).
    /// </summary>
    /// <param name="fromPath">The current file path</param>
    /// <param name="targetUid">The target UID to link to</param>
    /// <returns>The relative path (with anchor if applicable)</returns>
    public string ResolveInternalLink(string fromPath, string targetUid)
    {
        var targetInfo = GetOutputInfo(targetUid);
        
        // Calculate relative path
        var relativePath = CalculateRelativePath(fromPath, targetInfo.FilePath);
        
        // If same file, return anchor only
        if (string.IsNullOrEmpty(relativePath) && !string.IsNullOrEmpty(targetInfo.Anchor))
        {
            return $"#{targetInfo.Anchor}";
        }
        
        // Add anchor if present
        if (!string.IsNullOrEmpty(targetInfo.Anchor))
        {
            relativePath += $"#{targetInfo.Anchor}";
        }
        
        return relativePath;
    }
    
    /// <summary>
    /// Resolves an external link to a documentation URL.
    /// Uses YAML reference hrefs first, then falls back to generating Microsoft Docs URLs.
    /// </summary>
    /// <param name="uid">The external UID</param>
    /// <param name="fallbackUrl">Optional fallback URL if resolution fails</param>
    /// <returns>The external documentation URL</returns>
    public string ResolveExternalLink(string uid, string? fallbackUrl)
    {
        // First check if we have this reference from YAML metadata
        if (_externalReferences.TryGetValue(uid, out var href))
        {
            return href;
        }
        
        // Fallback: Generate Microsoft Docs URL for System.* and Microsoft.* types
        if (uid.StartsWith("System.", StringComparison.Ordinal) || 
            uid.StartsWith("Microsoft.", StringComparison.Ordinal))
        {
            // Remove generic arity markers (e.g., `1 in List`1)
            var cleanUid = uid.Replace("`", "-");
            var lowerUid = cleanUid.ToLowerInvariant();
            return $"https://learn.microsoft.com/dotnet/api/{lowerUid}";
        }
        
        return fallbackUrl ?? $"https://learn.microsoft.com/dotnet/api/{uid.ToLowerInvariant()}";
    }
    
    /// <summary>
    /// Determines if a UID is an external reference (not generated by us).
    /// A UID is internal if we generated a file for it in Pass 1.
    /// </summary>
    /// <param name="uid">The UID to check</param>
    /// <returns>True if external (not generated), false if internal (generated)</returns>
    public bool IsExternalReference(string uid)
    {
        // If we generated a file for this UID, it's internal (our documentation)
        if (_uidToOutputInfo.ContainsKey(uid))
        {
            return false;
        }
        
        // Otherwise it's external (either in references or completely unknown)
        return true;
    }
    
    #endregion
    
    #region Path Utilities
    
    /// <summary>
    /// Calculates the relative path from one file to another.
    /// </summary>
    /// <param name="fromPath">The source file path</param>
    /// <param name="toPath">The target file path</param>
    /// <returns>The relative path</returns>
    public string CalculateRelativePath(string fromPath, string toPath)
    {
        // Normalize paths
        fromPath = Path.GetFullPath(fromPath);
        toPath = Path.GetFullPath(toPath);
        
        // Same file
        if (string.Equals(fromPath, toPath, StringComparison.OrdinalIgnoreCase))
        {
            return "";
        }
        
        // Get directories
        var fromDir = Path.GetDirectoryName(fromPath) ?? "";
        var toDir = Path.GetDirectoryName(toPath) ?? "";
        var toFileName = Path.GetFileName(toPath);
        
        // Same directory
        if (string.Equals(fromDir, toDir, StringComparison.OrdinalIgnoreCase))
        {
            return toFileName;
        }
        
        // Split paths into segments
        var fromSegments = fromDir.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
        var toSegments = toDir.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
        
        // Find common ancestor
        int commonLength = 0;
        int minLength = Math.Min(fromSegments.Length, toSegments.Length);
        
        for (int i = 0; i < minLength; i++)
        {
            if (string.Equals(fromSegments[i], toSegments[i], StringComparison.OrdinalIgnoreCase))
            {
                commonLength++;
            }
            else
            {
                break;
            }
        }
        
        // Build relative path
        var relativeParts = new List<string>();
        
        // Add "../" for each level up from source
        int levelsUp = fromSegments.Length - commonLength;
        for (int i = 0; i < levelsUp; i++)
        {
            relativeParts.Add("..");
        }
        
        // Add remaining target path segments
        for (int i = commonLength; i < toSegments.Length; i++)
        {
            relativeParts.Add(toSegments[i]);
        }
        
        // Add filename
        relativeParts.Add(toFileName);
        
        // Join with forward slashes (for markdown/web)
        return string.Join("/", relativeParts);
    }
    
    #endregion
}
